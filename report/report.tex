\documentclass[12pt,a4paper]{article}
\usepackage[legalpaper, portrait, margin=3cm]{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{biblatex}

\graphicspath{ {./} }
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=blue,
  citecolor=blue,
  pdftitle={Relatório IA - Projeto - 2021/2022},
  pdfpagemode=FullScreen,
}
\addbibresource{./bibliography.bib}

\pagestyle{fancy}
\fancyhf{}
\rhead{Grupo \textbf{al002}}
\lhead{Relatório Projeto IA 2021/2022 LEIC-A}
\cfoot{Diogo Melita (99202) e Tomás Esteves (99341)}

\renewcommand{\footrulewidth}{0.2pt}

\renewcommand{\labelitemii}{$\circ$}
\renewcommand{\labelitemiii}{$\diamond$}

\begin{document}
  \section{Descrição do Problema e Implementação}

  Para o projeto de Inteligência Artificial foi pedido para desenvolver um programa em Python que resolvesse o problema Takuzu, utilizando técnicas de procura de IA.
  Para tal, começou-se por implementar as regras do jogo:

  \begin{itemize}
    \setlength{\itemsep}{0pt}
    \item Há um número igual de 0s e 1s em cada linha e coluna (ou mais um para grelhas de
    dimensão ímpar).
    \item Não há mais do que dois números iguais adjacentes, tanto horizontal como verticalmente.
    \item Todas as linhas são diferentes.
    \item Todas as colunas são diferentes.
  \end{itemize}

  Depois de implementadas as regras, rapidamente se percebeu que o tempo de execução do programa aumentava exponencialmente com o tamanho do tabuleiro (posições livres).
  Sendo o Takuzu conhecido também por Sudoku Binário inferiu-se que existem posições livres que podem ser ocupadas por uma peça dado um estado do tabuleiro. 
  Desta forma, foram implementados os seguintes casos:
  \begin{itemize}
    \setlength{\itemsep}{0pt}
    \item Se existirem 2 casas seguidas com o mesmo valor, as posições adjacentes em linha têm de ter obrigatoriamente o valor contrário a essas 2 casas.
    \item Se num tabuleiro par (ímpar), uma linha/coluna tiver metade (metade + 1) das casas preenchidas com um valor, sabemos obrigatoriamente que as casas vazias têm de ter o valor contrário. 
  \end{itemize}

  Contudo, mesmo com estas impelementações nem todos os tabuleiros se resolviam.
  Para isso, foi implementado um CSP que, numa primeira instância, tenta encontrar posições que apenas aceitam um valor.
  No caso de não encontrar, é atribuído um valor à primeira casa livre.
  Se, numa fase posterior do algoritmo, uma posição não tiver valores possíveis volta-se para trás e escolhe-se o outro valor para a variável.

  Tal permite resolver eficientemente tabuleiros de Takuzu com tamanhos grandes ($> 30$)
  

  \section{Análise Teórica}

  Para comparar algoritmos vamos usar como critérios o tempo de execução, o número de nós expandidos e o número de nós gerados.
  Para saber o tempo de execução foi feita a média de pelo menos 5 testes para cada input, recorrendo ao programa \href{https://github.com/sharkdp/hyperfine}{\textit{hyperfine}}.
  Para saber o número de nós expandidos e o número de nós gerados foi usado o código encontrado em search.py.

  // TODO add data

  
  Todas as procuras garantem completude apesar de umas serem mais eficientes que outras. Isto deve-se ao facto de, no caso de existir solução, as várias procuras poderem sempre testar todas as combinações de tabuleiro possíveis e chegar ao objetivo.
  Apesar de um puzzle de Takuzu poder ter mais do que uma solução possível, todas as soluções encontram-se sempre ao mesmo nível, que equivale ao número inicial de posições livres. Sendo assim, não é importante falar da otimilidade do algoritmo.
  Além de que para este projeto apenas consideram-se tabuleiros com 1 solução apenas.
  A heurística utilizada consiste em contar o número total de domínios das posições livres do tabuleiro.
  
  Assim, temos que a heurística, h(n), utilizada pode ser expressa da seguinte forma:
  $$
  h(n) = num\_total\_de\_domínios
  $$

  Esta heurística analisa cada posição livre e vê o tamanho do seu domínio que apenas pode ser 1 ou 2.
  Quanto menor o número total de domínios, mais perto está o Takuzu de estar acabado.
  
  Esta heurística, h(n), apenas melhora a perfomance do algoritmo, não melhorando a sua otimilidade.

  Podemos inferir que $h^*(n) = num\_pos\_livres$ dá o custo real do melhor caminho até a solução. Se houverem x posições livres, então apenas precisamos de fazer x ações.
  Para testar a admissibilidade da heurística basta verificar um estado onde uma posição livre tenha tamanho do domínio com valor 2, tornando a expressão $h(n) <= h^*(n)$ falsa,
  conluímos assim que a heurística h(n) não é admissível e consequentemente não é consistente.
\end{document}