\documentclass[12pt,a4paper]{article}
\usepackage[legalpaper, portrait, margin=3cm]{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{biblatex}

\graphicspath{ {./} }
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=blue,
  citecolor=blue,
  pdftitle={Relatório IA - Projeto - 2021/2022},
  pdfpagemode=FullScreen,
}
\addbibresource{./bibliography.bib}

\pagestyle{fancy}
\fancyhf{}
\rhead{Grupo \textbf{al002}}
\lhead{Relatório Projeto IA 2021/2022 LEIC-A}
\cfoot{Diogo Melita (99202) e Tomás Esteves (99341)}

\renewcommand{\footrulewidth}{0.2pt}

\renewcommand{\labelitemii}{$\circ$}
\renewcommand{\labelitemiii}{$\diamond$}

\begin{document}
  \section{Descrição do Problema e Implementação}

  Foi pedido para desenvolver um programa em Python que resolve o problema Takuzu utilizando técnicas de procura de IA.
  Começou-se por implementar as regras do jogo:

  \begin{itemize}
    \setlength{\itemsep}{0pt}
    \item Há um número igual de 1s e 0s em cada linha e coluna (ou mais um para grelhas de
    dimensão ímpar).
    \item Não há mais do que dois números iguais adjacentes (horizontal ou verticalmente) um ao
    outro.
    \item Todas as linhas são diferentes.
    \item Todas as colunas são diferentes.
  \end{itemize}

  Depois de implementadas as regras rapidamente percebeu-se que o tempo de execução do programa aumentava exponencialmente com o tamanho do tabuleiro (posições livres).
  Sendo o Takuzu conhecido também por Sudoku Binário inferiu-se que existem posições livres que podem ser ocupadas por uma peça dado um estado do tabuleiro. 
  Alguns dos casos implementados foram:
  \begin{itemize}
    \setlength{\itemsep}{0pt}
    \item Se houver 2 casas de seguida com o mesmo valor, as posições adjacentes em linha têm de ter obrigatoriamente ter o valor contrário a essas 2 casas.
    \item Se num tabuleiro par(ímpar) uma linha/coluna tiver metade(metade + 1) dos valores preenchidos com um valor, sabemos obrigatoriamente que as outras casas vazias têm de ser do valor contrário. 
  \end{itemize}

  Mesmo com estas impelementações nem todos os tabuleiros se resolviam.
  Para isso foi implementado um CSP onde primeiro tenta encontrar posições livres que apenas aceitam um valor.
  No caso de não encontrar é atribuído um valor à primeira casa livre.
  Se mais à frente no algoritmo, uma posição não tiver valores possíveis, volta-se para trás e escolhe-se o outro valor para a variável.

  Isto permite assim resolver eficientemente tabuleiros de Takuzu com tamanhos grandes($>$ 30)
  

  \section{Análise Teórica}

  Para comparar algoritmos vamos usar como critérios, o tempo de execução, o número de nós expandidos e o número de nós gerados.
  Para saber o tempo de execução foi feita a média de pelo menos 5 testes para cada input, recorrendo ao programa \href{https://github.com/sharkdp/hyperfine}{\textit{hyperfine}}.
  Para saber o número de nós expandidos e o número de nós gerados foi usado código encontrado em search.py.

  // TODO add data

  
  Todas as procuras garantem completude, apesar de umas serem mais eficientes que outras, isto deve-se a no caso de haver solução podem sempre testar todos as combinações de tabuleiro possíveis e chegar ao objetivo.
  Apesar de um puzzle de Takuzu poder ter mais do que 1 solução possível, todas as soluções encontram-se sempre todas ao mesmo nível que equivale ao número inicial de posições livres, sendo assim não é importante falar da otimilidade do algoritmo.
  
  A heurística usada consiste em relacionar o número de posições livres e a linha em que a ação está a ser feita.
  Dado a maneira como foi desenvolvido o algoritmo, quando é necessário fazer uma escolha entre os dois valores, é escolhido a primeira
  posição livre,
  Como se vizualiza o tabuleiro da esquerda para a direita e de cima para baixo, uma escolha numa linha mais abaixo significa que o resto das posições livres se encontram mais concentradas, logo havendo maior probabilidade de o puzzle acabar mais rápido.
  Assim temos que
  $$
  h(n) = {num\_de\_pos\_lives} + \frac{1}{num\_actions} * (size\_board - 1 - num_row_of_action)
  $$

  Temos que um tabuleiro com menos número de posições livres é superior a um que tenha mais.
  Considera-se que numa posição livre onde podem ocorrer as 2 ações vai ser pior que numa onde apenas pode acontecer 1 ação.
  Assim saber onde a ação foi feita tem menos importância quando apenas há 1 ação. 
  
  Esta heurística apenas melhora a perfomance do algoritmo, não melhorando a sua otimilidade. 

  Temos ainda que $h*(n) = num\_pos\_livres$, e como $(\frac{1}{num\_actions} * (size\_board - 1 - num\_row\_of\_action)) > 0$ podemos concluir que esta heurística não é admissível, e não consistente.


\end{document}